#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba8, binding = 0) uniform writeonly image2D uOutput;
layout(std430, binding = 0) readonly buffer Voxels { uint data[]; };

// -------- uniforms --------
uniform ivec3 uWorldSize;
uniform ivec3 uRegionOrigin;
uniform vec3  uCamPos;
uniform mat4  uInvProj;
uniform mat4  uInvView;
uniform vec3  uSunDir;          // normalized
uniform ivec2 uResolution;
uniform float uVoxelScale;
uniform int   uDebugGradient;

// Sky model / Preetham
uniform int   uSkyModel;        // 0=gradient, 1=Preetham
uniform float uTurbidity;       // ~2–3 clear, 6–8 hazy
uniform vec3  uSkyZenith;       // fallback gradient top
uniform vec3  uSkyHorizon;      // fallback gradient bottom
uniform float uSkyIntensity;    // global sky multiplier

// Soft sun shadow params
uniform float uSunAngularRadius; // radians (~0.00465)
uniform int   uSunSoftSamples;   // 8–16 recommended

// Player torch (soft point/area)
uniform int   uTorchEnabled;
uniform vec3  uTorchPos;        // world voxel coords
uniform float uTorchIntensity;
uniform float uTorchRadius;     // area radius
uniform int   uTorchSoftSamples;

// -------- constants / utils --------
const float PI  = 3.14159265359;
const float TAU = 6.28318530718;
const float GOLDEN_ANGLE = 2.39996322973;

float saturate(float x){ return clamp(x, 0.0, 1.0); }

vec3 skyGradient(vec3 dir){
    float t = 0.5*(dir.y*0.5 + 0.5);
    return mix(uSkyZenith, uSkyHorizon, 1.0 - t);
}

void makeONB(in vec3 n, out vec3 t, out vec3 b){
    if (abs(n.z) < 0.999) t = normalize(cross(n, vec3(0,0,1)));
    else                  t = normalize(cross(n, vec3(0,1,0)));
    b = cross(n, t);
}

// -------- Preetham daylight (no vec5!) --------
// Perez coefficients (A..E) via out params
void coeffsY(float T, out float A, out float B, out float C, out float D, out float E){
    A =  0.17872*T - 1.46303;
    B = -0.35540*T + 0.42749;
    C = -0.02266*T + 5.32505;
    D =  0.12064*T - 2.57705;
    E = -0.06696*T + 0.37027;
}
void coeffsX(float T, out float A, out float B, out float C, out float D, out float E){
    A = -0.01925*T - 0.25922;
    B = -0.06651*T + 0.00081;
    C = -0.00041*T + 0.21247;
    D = -0.06409*T - 0.89887;
    E = -0.00325*T + 0.04517;
}
void coeffsYc(float T, out float A, out float B, out float C, out float D, out float E){
    A = -0.01669*T - 0.26078;
    B = -0.09495*T + 0.00921;
    C = -0.00792*T + 0.21023;
    D = -0.04405*T - 1.65369;
    E = -0.01092*T + 0.05291;
}

float zenithY(float T, float thetaS){
    float chi = (4.0/9.0 - T/120.0) * (PI - 2.0*thetaS);
    return ((4.0453*T - 4.9710) * tan(chi) - 0.2155*T + 2.4192) * 1000.0; // cd/m^2
}
float zenithx(float T, float thetaS){
    float t = thetaS;
    return ( 0.00165*t*t*t - 0.00374*t*t + 0.00208*t ) * T*T
    + (-0.02902*t*t*t + 0.06377*t*t - 0.03202*t + 0.00394) * T
    + ( 0.11693*t*t*t - 0.21196*t*t + 0.06052*t + 0.25885);
}
float zenithy(float T, float thetaS){
    float t = thetaS;
    return ( 0.00275*t*t*t - 0.00610*t*t + 0.00317*t ) * T*T
    + (-0.04214*t*t*t + 0.08970*t*t - 0.04153*t + 0.00516) * T
    + ( 0.15346*t*t*t - 0.26756*t*t + 0.06669*t + 0.26688);
}

vec3 preethamSkyRGB(vec3 dir, vec3 sunDir, float T){
    dir = normalize(dir); sunDir = normalize(sunDir);
    float cosTheta = clamp(dir.y, 0.0, 1.0);
    float theta    = acos(cosTheta);
    float cosThetaS= clamp(sunDir.y, 0.0, 1.0);
    float thetaS   = acos(cosThetaS);
    float gamma    = acos(clamp(dot(dir, sunDir), -1.0, 1.0));

    // Coeffs
    float Ax,Bx,Cx,Dx,Ex; coeffsX(T,  Ax,Bx,Cx,Dx,Ex);
    float Ay,By,Cy,Dy,Ey; coeffsYc(T, Ay,By,Cy,Dy,Ey);
    float AY,BY,CY,DY,EY; coeffsY(T,  AY,BY,CY,DY,EY);

    // Perez terms (normalized with zenith configuration)
    float denomX = (1.0 + Ax*exp(Bx) + Cx*exp(Dx*thetaS) + Ex*cos(thetaS)*cos(thetaS));
    float denomYc= (1.0 + Ay*exp(By) + Cy*exp(Dy*thetaS) + Ey*cos(thetaS)*cos(thetaS));
    float denomY = (1.0 + AY*exp(BY) + CY*exp(DY*thetaS) + EY*cos(thetaS)*cos(thetaS));

    float numX = (1.0 + Ax*exp(Bx/(cosTheta+1e-5)) + Cx*exp(Dx*gamma) + Ex*cos(gamma)*cos(gamma));
    float numYc= (1.0 + Ay*exp(By/(cosTheta+1e-5)) + Cy*exp(Dy*gamma) + Ey*cos(gamma)*cos(gamma));
    float numY = (1.0 + AY*exp(BY/(cosTheta+1e-5)) + CY*exp(DY*gamma) + EY*cos(gamma)*cos(gamma));

    float Px = numX / denomX;
    float Py = numYc/ denomYc;
    float PY = numY / denomY;

    float Yz = zenithY(T, thetaS);
    float xz = zenithx(T, thetaS);
    float yz = zenithy(T, thetaS);

    float x = saturate(Px * xz);
    float y = saturate(Py * yz);
    float Y = max(0.0, PY * Yz); // luminance

    // xyY -> XYZ
    float X = (y > 1e-5) ? (Y * x / y) : 0.0;
    float Z = (y > 1e-5) ? (Y * (1.0 - x - y) / y) : 0.0;

    // XYZ -> linear sRGB
    vec3 rgb = mat3(  3.2406, -1.5372, -0.4986,
    -0.9689,  1.8758,  0.0415,
    0.0557, -0.2040,  1.0570) * vec3(X, Y, Z);

    // Bring into [0,1]-ish range (empirical scale; adjust with uSkyIntensity)
    rgb *= 1.0/60000.0;
    return max(rgb, vec3(0.0));
}

vec3 envSky(vec3 dir){
    return (uSkyModel==1)
    ? preethamSkyRGB(dir, uSunDir, uTurbidity) * uSkyIntensity
    : skyGradient(dir) * uSkyIntensity;
}

// -------- voxel helpers --------
bool inBounds(ivec3 p){
    return all(greaterThanEqual(p, ivec3(0))) && all(lessThan(p, uWorldSize));
}
uint loadVoxel(ivec3 local){
    if (!inBounds(local)) return 0u;
    int idx = local.x + uWorldSize.x * (local.y + uWorldSize.y * local.z);
    return data[idx];
}

// DDA traverse: returns true if any solid voxel is hit
bool traverseHitAny(vec3 startP, vec3 dir){
    vec3 rd = normalize(dir);
    vec3 p  = startP;
    ivec3 v = ivec3(floor(p));

    vec3  dirStep = sign(rd);
    ivec3 stepI   = ivec3(dirStep);
    ivec3 off     = ivec3(stepI.x > 0 ? 1 : 0,
    stepI.y > 0 ? 1 : 0,
    stepI.z > 0 ? 1 : 0);

    vec3 nextBoundary = vec3(v + off);
    vec3 tMax3  = (nextBoundary - p) / rd;
    vec3 tDelta = abs(1.0 / rd);

    for (int i=0; i<4096; ++i){
        if (!inBounds(v)) return false;
        if (loadVoxel(v) != 0u) return true;

        if (tMax3.x < tMax3.y){
            if (tMax3.x < tMax3.z){ v.x += stepI.x; tMax3.x += tDelta.x; }
            else { v.z += stepI.z; tMax3.z += tDelta.z; }
        } else {
            if (tMax3.y < tMax3.z){ v.y += stepI.y; tMax3.y += tDelta.y; }
            else { v.z += stepI.z; tMax3.z += tDelta.z; }
        }
    }
    return false;
}

// Soft sun visibility (cone samples around uSunDir)
float sunVisibility(vec3 pHit, vec3 n){
    vec3 S = normalize(uSunDir);
    float ndl = max(dot(n, S), 0.0);
    if (ndl <= 0.0) return 0.0;

    vec3 T,B; makeONB(S, T, B);
    float halfAngle = uSunAngularRadius;
    int   N = max(uSunSoftSamples, 1);

    float vis = 0.0;
    for (int i=0; i<N; ++i){
        float u = (float(i)+0.5)/float(N);
        float a = halfAngle * sqrt(u);     // concentrate samples near center
        float ang = GOLDEN_ANGLE * float(i);
        vec2  d  = vec2(cos(ang), sin(ang)) * tan(a); // offset on tangent disk
        vec3  L  = normalize(S + d.x*T + d.y*B);
        bool  oc = traverseHitAny(pHit + L*1e-3, L);
        vis += oc ? 0.0 : 1.0;
    }
    return vis / float(N);
}

// Torch visibility (soft via small emitter radius)
float torchVisibilitySoft(vec3 pHit, vec3 Ldir, float dist){
    int N = max(uTorchSoftSamples, 1);
    if (uTorchRadius <= 1e-5 || N==1){
        bool oc = traverseHitAny(pHit + Ldir*1e-3, Ldir);
        return oc ? 0.0 : 1.0;
    }
    vec3 center = uTorchPos;
    vec3 W = normalize(center - pHit);
    vec3 T,B; makeONB(W, T, B);

    float sum = 0.0;
    for (int i=0; i<N; ++i){
        float u = (float(i)+0.5)/float(N);
        float ang = GOLDEN_ANGLE * float(i);
        float r = uTorchRadius * sqrt(u);
        vec3  target = center + r*(cos(ang)*T + sin(ang)*B);
        vec3  L = normalize(target - pHit);
        bool  oc = traverseHitAny(pHit + L*1e-3, L);
        sum += oc ? 0.0 : 1.0;
    }
    return sum / float(N);
}

vec3 blockColor(uint id){
    if (id==1u) return vec3(0.27, 0.62, 0.23); // GRASS
    if (id==2u) return vec3(0.35, 0.22, 0.12); // DIRT
    if (id==3u) return vec3(0.50, 0.50, 0.50); // STONE
    if (id==4u) return vec3(0.82, 0.76, 0.52); // SAND
    if (id==5u) return vec3(0.95, 0.95, 0.97); // SNOW
    return vec3(0.0);
}

// Skylight: cosine-weighted hemisphere sample of envSky with occlusion
vec3 computeSkyIrradiance(vec3 pHit, vec3 n){
    const int SKY_SAMPLES = 12;
    vec3 sum = vec3(0.0);
    float W  = 0.0;

    for (int i=0; i<SKY_SAMPLES; ++i){
        float u = (float(i)+0.5)/float(SKY_SAMPLES);
        float phi = GOLDEN_ANGLE * float(i);
        float y = u;
        float r = sqrt(max(0.0, 1.0 - y*y));
        vec3  L = vec3(cos(phi)*r, y, sin(phi)*r); // world-up oriented
        float k = max(dot(n, L), 0.0);
        if (k <= 0.0) continue;
        bool oc = traverseHitAny(pHit + L*1e-3, L);
        if (!oc) sum += envSky(L) * k;
        W += k;
    }
    return (W > 0.0) ? (sum / W) : vec3(0.0);
}

// --------------------------- main ---------------------------
void main(){
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= uResolution.x || gid.y >= uResolution.y) return;

    // Primary ray
    vec2 uv = (vec2(gid) + vec2(0.5)) / vec2(uResolution) * 2.0 - 1.0;
    vec4 pNear = uInvProj * vec4(uv, -1.0, 1.0);
    vec4 pFar  = uInvProj * vec4(uv,  1.0, 1.0);
    pNear /= pNear.w; pFar /= pFar.w;

    vec3 ro = uCamPos;
    vec3 rd = normalize((uInvView * vec4(normalize(pFar.xyz - pNear.xyz), 0.0)).xyz);
    vec3 roLocal = ro - vec3(uRegionOrigin);

    // Region AABB
    vec3 tMin = (vec3(0.0) - roLocal) / rd;
    vec3 tMax = (vec3(uWorldSize) - roLocal) / rd;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tEnter = max(max(t1.x, t1.y), t1.z);
    float tExit  = min(min(t2.x, t2.y), t2.z);
    if (tExit < max(tEnter, 0.0)){
        imageStore(uOutput, gid, vec4(envSky(rd),1.0));
        return;
    }

    // DDA setup
    vec3 p = roLocal + rd * max(tEnter, 0.0);
    ivec3 v = ivec3(floor(p));
    vec3  dirStep = sign(rd);
    ivec3 stepI   = ivec3(dirStep);
    ivec3 off     = ivec3(stepI.x > 0 ? 1 : 0,
    stepI.y > 0 ? 1 : 0,
    stepI.z > 0 ? 1 : 0);
    vec3 nextBoundary = vec3(v + off);
    vec3 tMax3  = (nextBoundary - p) / rd;
    vec3 tDelta = abs(1.0 / rd);

    vec3 lastN = vec3(0.0);
    bool hit = false;
    uint blockId = 0u;
    vec3 color = vec3(0.0);

    for (int iter=0; iter<4096; ++iter){
        if (!inBounds(v)) break;

        blockId = loadVoxel(v);
        if (blockId != 0u){
            bool hasLast = any(notEqual(lastN, vec3(0.0)));
            vec3 n = hasLast ? normalize(lastN) : normalize(-rd);

            // Sun (soft) + Skylight + Torch
            vec3 pHit = vec3(v) + vec3(0.5) + 0.5 * n;

            vec3 Ls = normalize(uSunDir);
            float ndl = max(dot(n, Ls), 0.0);
            float sunVis = (ndl > 0.0) ? sunVisibility(pHit, n) : 0.0;

            float torchTerm = 0.0;
            if (uTorchEnabled != 0){
                vec3 toTorch = uTorchPos - pHit;
                float dist = length(toTorch);
                if (dist > 1e-3){
                    vec3 Lt = toTorch / dist;
                    float ndl_t = max(dot(n, Lt), 0.0);
                    if (ndl_t > 0.0){
                        float visT = torchVisibilitySoft(pHit, Lt, dist);
                        float atten = 1.0 / max(1.0, dist*dist);
                        torchTerm = uTorchIntensity * ndl_t * visT * atten;
                    }
                }
            }

            vec3 albedo = blockColor(blockId);
            vec3 directSun = albedo * (ndl * sunVis);
            vec3 skyl      = albedo * computeSkyIrradiance(pHit, n);

            color = directSun + skyl + albedo * torchTerm;
            hit = true; break;
        }

        if (tMax3.x < tMax3.y){
            if (tMax3.x < tMax3.z){ v.x += stepI.x; tMax3.x += tDelta.x; lastN = vec3(-dirStep.x,0,0); }
            else { v.z += stepI.z; tMax3.z += tDelta.z; lastN = vec3(0,0,-dirStep.z); }
        } else {
            if (tMax3.y < tMax3.z){ v.y += stepI.y; tMax3.y += tDelta.y; lastN = vec3(0,-dirStep.y,0); }
            else { v.z += stepI.z; tMax3.z += tDelta.z; lastN = vec3(0,0,-dirStep.z); }
        }
    }

    imageStore(uOutput, gid, vec4(hit ? color : envSky(rd), 1.0));
}
