#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba8, binding = 0) uniform writeonly image2D uOutput;
layout(std430, binding = 0) readonly buffer Voxels { uint data[]; };
layout(std430, binding = 1) readonly buffer VoxelsCoarse { uint dataCoarse[]; };
layout(std430, binding = 2) readonly buffer VoxelsFar { uint dataFar[]; };

// -------- uniforms --------
uniform ivec3 uWorldSize;
uniform ivec3 uWorldSizeCoarse;
uniform ivec3 uWorldSizeFar;
uniform ivec3 uRegionOrigin;
uniform vec3  uCamPos;
uniform mat4  uInvProj;
uniform mat4  uInvView;
uniform vec3  uSunDir;// normalized
uniform ivec2 uResolution;
uniform float uVoxelScale;
uniform float uLodScale;
uniform float uLodScaleFar;
uniform float uLodSwitchDistance;
uniform float uLodSwitchDistanceFar;
uniform float uLodTransitionBand;
uniform int   uDebugGradient;

// Sky model / Preetham
uniform int   uSkyModel;// 0=gradient, 1=Preetham
uniform float uTurbidity;// ~2–3 clear, 6–8 hazy
uniform vec3  uSkyZenith;// fallback gradient top
uniform vec3  uSkyHorizon;// fallback gradient bottom
uniform float uSkyIntensity;// global sky multiplier

// Soft sun shadow params
uniform float uSunAngularRadius;// radians (~0.00465)
uniform int   uSunSoftSamples;// 8–16 recommended

// Player torch (soft point/area)
uniform int   uTorchEnabled;
uniform vec3  uTorchPos;// world voxel coords
uniform float uTorchIntensity;
uniform float uTorchRadius;// area radius
uniform int   uTorchSoftSamples;

// Secondary lighting & effects
uniform int   uGIEnabled;
uniform int   uGISampleCount;
uniform float uGIMaxDistance;
uniform float uGIIntensity;
uniform int   uGIVolumeEnabled;
uniform sampler3D uGIVolume;
uniform ivec3 uGIVolumeSize;
uniform vec3  uGIVolumeOrigin;
uniform float uGIVolumeCellSize;
uniform int   uSecondaryTraceMaxSteps;

uniform int   uAOEnabled;
uniform int   uAOSampleCount;
uniform float uAORadius;
uniform float uAOIntensity;

uniform int   uReflectionEnabled;
uniform float uReflectionMaxDistance;
uniform float uReflectionIntensity;

const int MAX_DYNAMIC_LIGHTS = 8;
uniform int   uLightCount;
uniform vec4  uLightPositions[MAX_DYNAMIC_LIGHTS]; // xyz=position, w=range
uniform vec4  uLightColors[MAX_DYNAMIC_LIGHTS];    // rgb=color,  a=intensity
uniform float uLightRadii[MAX_DYNAMIC_LIGHTS];     // emitter radius
uniform int   uLightSoftSamples;

uniform int   uShadowTraceMaxSteps;
uniform int   uShadowOccupancyScale;

// -------- constants / utils --------
const float PI  = 3.14159265359;
const float TAU = 6.28318530718;
const float GOLDEN_ANGLE = 2.39996322973;
const int   MAX_GI_SAMPLES = 32;
const int   MAX_AO_SAMPLES = 32;

float saturate(float x){ return clamp(x, 0.0, 1.0); }

vec3 skyGradient(vec3 dir){
    float t = 0.5*(dir.y*0.5 + 0.5);
    return mix(uSkyZenith, uSkyHorizon, 1.0 - t);
}

void makeONB(in vec3 n, out vec3 t, out vec3 b){
    if (abs(n.z) < 0.999) t = normalize(cross(n, vec3(0, 0, 1)));
    else t = normalize(cross(n, vec3(0, 1, 0)));
    b = cross(n, t);
}

// -------- Preetham daylight (no vec5!) --------
// Perez coefficients (A..E) via out params
void coeffsY(float T, out float A, out float B, out float C, out float D, out float E){
    A =  0.17872*T - 1.46303;
    B = -0.35540*T + 0.42749;
    C = -0.02266*T + 5.32505;
    D =  0.12064*T - 2.57705;
    E = -0.06696*T + 0.37027;
}
void coeffsX(float T, out float A, out float B, out float C, out float D, out float E){
    A = -0.01925*T - 0.25922;
    B = -0.06651*T + 0.00081;
    C = -0.00041*T + 0.21247;
    D = -0.06409*T - 0.89887;
    E = -0.00325*T + 0.04517;
}
void coeffsYc(float T, out float A, out float B, out float C, out float D, out float E){
    A = -0.01669*T - 0.26078;
    B = -0.09495*T + 0.00921;
    C = -0.00792*T + 0.21023;
    D = -0.04405*T - 1.65369;
    E = -0.01092*T + 0.05291;
}

float zenithY(float T, float thetaS){
    float chi = (4.0/9.0 - T/120.0) * (PI - 2.0*thetaS);
    return ((4.0453*T - 4.9710) * tan(chi) - 0.2155*T + 2.4192) * 1000.0;// cd/m^2
}
float zenithx(float T, float thetaS){
    float t = thetaS;
    return (0.00165*t*t*t - 0.00374*t*t + 0.00208*t) * T*T
    + (-0.02902*t*t*t + 0.06377*t*t - 0.03202*t + 0.00394) * T
    + (0.11693*t*t*t - 0.21196*t*t + 0.06052*t + 0.25885);
}
float zenithy(float T, float thetaS){
    float t = thetaS;
    return (0.00275*t*t*t - 0.00610*t*t + 0.00317*t) * T*T
    + (-0.04214*t*t*t + 0.08970*t*t - 0.04153*t + 0.00516) * T
    + (0.15346*t*t*t - 0.26756*t*t + 0.06669*t + 0.26688);
}

vec3 preethamSkyRGB(vec3 dir, vec3 sunDir, float T){
    dir = normalize(dir); sunDir = normalize(sunDir);
    float cosTheta = clamp(dir.y, 0.0, 1.0);
    float theta    = acos(cosTheta);
    float cosThetaS= clamp(sunDir.y, 0.0, 1.0);
    float thetaS   = acos(cosThetaS);
    float gamma    = acos(clamp(dot(dir, sunDir), -1.0, 1.0));

    // Coeffs
    float Ax, Bx, Cx, Dx, Ex; coeffsX(T, Ax, Bx, Cx, Dx, Ex);
    float Ay, By, Cy, Dy, Ey; coeffsYc(T, Ay, By, Cy, Dy, Ey);
    float AY, BY, CY, DY, EY; coeffsY(T, AY, BY, CY, DY, EY);

    // Perez terms (normalized with zenith configuration)
    float denomX = (1.0 + Ax*exp(Bx) + Cx*exp(Dx*thetaS) + Ex*cos(thetaS)*cos(thetaS));
    float denomYc= (1.0 + Ay*exp(By) + Cy*exp(Dy*thetaS) + Ey*cos(thetaS)*cos(thetaS));
    float denomY = (1.0 + AY*exp(BY) + CY*exp(DY*thetaS) + EY*cos(thetaS)*cos(thetaS));

    float numX = (1.0 + Ax*exp(Bx/(cosTheta+1e-5)) + Cx*exp(Dx*gamma) + Ex*cos(gamma)*cos(gamma));
    float numYc= (1.0 + Ay*exp(By/(cosTheta+1e-5)) + Cy*exp(Dy*gamma) + Ey*cos(gamma)*cos(gamma));
    float numY = (1.0 + AY*exp(BY/(cosTheta+1e-5)) + CY*exp(DY*gamma) + EY*cos(gamma)*cos(gamma));

    float Px = numX / denomX;
    float Py = numYc/ denomYc;
    float PY = numY / denomY;

    float Yz = zenithY(T, thetaS);
    float xz = zenithx(T, thetaS);
    float yz = zenithy(T, thetaS);

    float x = saturate(Px * xz);
    float y = saturate(Py * yz);
    float Y = max(0.0, PY * Yz);// luminance

    // xyY -> XYZ
    float X = (y > 1e-5) ? (Y * x / y) : 0.0;
    float Z = (y > 1e-5) ? (Y * (1.0 - x - y) / y) : 0.0;

    // XYZ -> linear sRGB
    vec3 rgb = mat3(3.2406, -1.5372, -0.4986,
    -0.9689, 1.8758, 0.0415,
    0.0557, -0.2040, 1.0570) * vec3(X, Y, Z);

    // Bring into [0,1]-ish range (empirical scale; adjust with uSkyIntensity)
    rgb *= 1.0/60000.0;
    return max(rgb, vec3(0.0));
}

vec3 envSky(vec3 dir){
    return (uSkyModel==1)
    ? preethamSkyRGB(dir, uSunDir, uTurbidity) * uSkyIntensity
    : skyGradient(dir) * uSkyIntensity;
}

// -------- voxel helpers --------
bool inBounds(ivec3 p){
    return all(greaterThanEqual(p, ivec3(0))) && all(lessThan(p, uWorldSize));
}
uint loadVoxel(ivec3 local){
    if (!inBounds(local)) return 0u;
    int idx = local.x + uWorldSize.x * (local.y + uWorldSize.y * local.z);
    return data[idx];
}

bool inBoundsCoarse(ivec3 p){
    return all(greaterThanEqual(p, ivec3(0))) && all(lessThan(p, uWorldSizeCoarse));
}
uint loadVoxelCoarse(ivec3 local){
    if (!inBoundsCoarse(local)) return 0u;
    int idx = local.x + uWorldSizeCoarse.x * (local.y + uWorldSizeCoarse.y * local.z);
    return dataCoarse[idx];
}

bool inBoundsFar(ivec3 p){
    return all(greaterThanEqual(p, ivec3(0))) && all(lessThan(p, uWorldSizeFar));
}
uint loadVoxelFar(ivec3 local){
    if (!inBoundsFar(local)) return 0u;
    int idx = local.x + uWorldSizeFar.x * (local.y + uWorldSizeFar.y * local.z);
    return dataFar[idx];
}

// DDA traverse: returns true if any solid voxel is hit before maxDistance (negative = infinite)
bool traverseHitAnyDistance(vec3 startP, vec3 dir, float maxDistance){
    vec3 rd = normalize(dir);
    vec3 p  = startP;
    ivec3 v = ivec3(floor(p));

    vec3  dirStep = sign(rd);
    ivec3 stepI   = ivec3(dirStep);
    ivec3 off     = ivec3(stepI.x > 0 ? 1 : 0,
                          stepI.y > 0 ? 1 : 0,
                          stepI.z > 0 ? 1 : 0);

    vec3 nextBoundary = vec3(v + off);
    vec3 tMax3  = (nextBoundary - p) / rd;
    vec3 tDelta = abs(1.0 / rd);

    int maxSteps = max(uShadowTraceMaxSteps, 1);
    int occupancyScale = max(uShadowOccupancyScale, 1);
    float t = 0.0;

    for (int i=0; i<maxSteps; ++i){
        if (maxDistance > 0.0 && t > maxDistance) return false;
        if (!inBounds(v)) return false;
        if (loadVoxel(v) != 0u) return true;

        bool skipped = false;
        if (occupancyScale > 1){
            ivec3 coarse = ivec3(floor(vec3(v) / float(occupancyScale)));
            if (inBoundsCoarse(coarse)){
                if (loadVoxelCoarse(coarse) == 0u){
                    for (int s=0; s<occupancyScale; ++s){
                        if (tMax3.x < tMax3.y){
                            if (tMax3.x < tMax3.z){
                                v.x += stepI.x;
                                t = tMax3.x;
                                tMax3.x += tDelta.x;
                            } else {
                                v.z += stepI.z;
                                t = tMax3.z;
                                tMax3.z += tDelta.z;
                            }
                        } else {
                            if (tMax3.y < tMax3.z){
                                v.y += stepI.y;
                                t = tMax3.y;
                                tMax3.y += tDelta.y;
                            } else {
                                v.z += stepI.z;
                                t = tMax3.z;
                                tMax3.z += tDelta.z;
                            }
                        }
                        if (!inBounds(v)) return false;
                        if (maxDistance > 0.0 && t > maxDistance) return false;
                    }
                    skipped = true;
                }
            }
        }
        if (skipped) continue;

        if (tMax3.x < tMax3.y){
            if (tMax3.x < tMax3.z){ v.x += stepI.x; t = tMax3.x; tMax3.x += tDelta.x; }
            else { v.z += stepI.z; t = tMax3.z; tMax3.z += tDelta.z; }
        } else {
            if (tMax3.y < tMax3.z){ v.y += stepI.y; t = tMax3.y; tMax3.y += tDelta.y; }
            else { v.z += stepI.z; t = tMax3.z; tMax3.z += tDelta.z; }
        }
    }
    return false;
}

bool traverseHitAny(vec3 startP, vec3 dir){
    return traverseHitAnyDistance(startP, dir, -1.0);
}

bool traceVoxel(vec3 origin, vec3 dir, float maxDistance, int maxSteps, out vec3 hitPos, out vec3 hitNormal, out uint hitId){
    vec3 rd = normalize(dir);
    vec3 p = origin;
    ivec3 v = ivec3(floor(p));

    vec3 dirStep = sign(rd);
    ivec3 stepI = ivec3(dirStep);
    ivec3 off = ivec3(stepI.x > 0 ? 1 : 0,
                      stepI.y > 0 ? 1 : 0,
                      stepI.z > 0 ? 1 : 0);

    vec3 nextBoundary = vec3(v + off);
    vec3 tMax3 = (nextBoundary - p) / rd;
    vec3 tDelta = abs(1.0 / rd);
    vec3 lastN = vec3(0.0);

    hitPos = vec3(0.0);
    hitNormal = vec3(0.0);
    hitId = 0u;

    float t = 0.0;
    int steps = max(maxSteps, 1);
    for (int i=0; i<steps; ++i){
        if (maxDistance > 0.0 && t > maxDistance) break;

        if (tMax3.x < tMax3.y){
            if (tMax3.x < tMax3.z){
                v.x += stepI.x;
                lastN = vec3(-dirStep.x, 0.0, 0.0);
                t = tMax3.x;
                tMax3.x += tDelta.x;
            } else {
                v.z += stepI.z;
                lastN = vec3(0.0, 0.0, -dirStep.z);
                t = tMax3.z;
                tMax3.z += tDelta.z;
            }
        } else {
            if (tMax3.y < tMax3.z){
                v.y += stepI.y;
                lastN = vec3(0.0, -dirStep.y, 0.0);
                t = tMax3.y;
                tMax3.y += tDelta.y;
            } else {
                v.z += stepI.z;
                lastN = vec3(0.0, 0.0, -dirStep.z);
                t = tMax3.z;
                tMax3.z += tDelta.z;
            }
        }

        if (!inBounds(v)) break;
        if (maxDistance > 0.0 && t > maxDistance) break;

        uint id = loadVoxel(v);
        if (id != 0u){
            hitId = id;
            hitNormal = normalize(lastN);
            if (length(hitNormal) < 0.5) hitNormal = normalize(-rd);
            hitPos = vec3(v) + vec3(0.5) + 0.5 * hitNormal;
            return true;
        }
    }
    return false;
}

// Soft sun visibility (cone samples around uSunDir)
float sunVisibility(vec3 pHit, vec3 n){
    vec3 S = normalize(uSunDir);
    float ndl = max(dot(n, S), 0.0);
    if (ndl <= 0.0) return 0.0;

    vec3 T, B; makeONB(S, T, B);
    float halfAngle = uSunAngularRadius;
    int   N = max(uSunSoftSamples, 1);

    float vis = 0.0;
    for (int i=0; i<N; ++i){
        float u = (float(i)+0.5)/float(N);
        float a = halfAngle * sqrt(u);// concentrate samples near center
        float ang = GOLDEN_ANGLE * float(i);
        vec2  d  = vec2(cos(ang), sin(ang)) * tan(a);// offset on tangent disk
        vec3  L  = normalize(S + d.x*T + d.y*B);
        bool  oc = traverseHitAny(pHit + L*1e-3, L);
        vis += oc ? 0.0 : 1.0;
    }
    return vis / float(N);
}

float sampleAreaLightVisibility(vec3 pHit, vec3 lightPos, float radius, float range, int samples, vec3 fallbackDir){
    int N = max(samples, 1);
    vec3 toCenter = lightPos - pHit;
    float centerDist = length(toCenter);
    vec3 dir = (centerDist > 1e-5) ? (toCenter / centerDist) : fallbackDir;
    float maxTravel = centerDist;
    if (range > 0.0) {
        maxTravel = min(maxTravel, range);
    }
    if (radius <= 1e-5 || N == 1){
        vec3 rayDir = (radius <= 1e-5) ? dir : fallbackDir;
        float limit = max(0.0, maxTravel - 1e-3);
        bool oc = traverseHitAnyDistance(pHit + rayDir*1e-3, rayDir, limit);
        return oc ? 0.0 : 1.0;
    }

    vec3 center = lightPos;
    vec3 W = (length(dir) > 1e-5) ? dir : fallbackDir;
    if (length(W) < 1e-5) W = vec3(0.0, 1.0, 0.0);
    W = normalize(W);
    vec3 T, B; makeONB(W, T, B);

    float sum = 0.0;
    for (int i=0; i<N; ++i){
        float u = (float(i)+0.5)/float(N);
        float ang = GOLDEN_ANGLE * float(i);
        float r = radius * sqrt(u);
        vec3 target = center + r*(cos(ang)*T + sin(ang)*B);
        vec3 L = normalize(target - pHit);
        float sampleDist = length(target - pHit);
        float limit = sampleDist;
        if (range > 0.0) {
            limit = min(limit, range);
        }
        bool oc = traverseHitAnyDistance(pHit + L*1e-3, L, max(0.0, limit - 1e-3));
        sum += oc ? 0.0 : 1.0;
    }
    return sum / float(N);
}

vec3 evaluateAreaLight(vec3 albedo, vec3 pHit, vec3 n, vec3 lightPos, vec3 lightColor, float intensity, float radius, float range, int samples){
    vec3 toLight = lightPos - pHit;
    float dist = length(toLight);
    if (dist <= 1e-4) return vec3(0.0);
    if (range > 0.0 && dist > range) return vec3(0.0);
    vec3 Ldir = toLight / dist;
    float ndl = max(dot(n, Ldir), 0.0);
    if (ndl <= 0.0) return vec3(0.0);
    float vis = sampleAreaLightVisibility(pHit, lightPos, radius, range, samples, Ldir);
    float atten = intensity / max(1.0, dist * dist);
    return albedo * lightColor * ndl * vis * atten;
}

vec3 blockColor(uint id){
    if (id==1u) return vec3(0.27, 0.62, 0.23);// GRASS
    if (id==2u) return vec3(0.35, 0.22, 0.12);// DIRT
    if (id==3u) return vec3(0.50, 0.50, 0.50);// STONE
    if (id==4u) return vec3(0.82, 0.76, 0.52);// SAND
    if (id==5u) return vec3(0.95, 0.95, 0.97);// SNOW
    if (id==6u) return vec3(0.43, 0.29, 0.18);// LOG
    if (id==7u) return vec3(0.21, 0.45, 0.15);// LEAVES
    if (id==8u) return vec3(0.29, 0.46, 0.28);// CACTUS
    return vec3(0.0);
}

float blockReflectivity(uint id){
    if (id==5u) return 0.25;// snow/ice
    if (id==3u) return 0.12;// stone
    if (id==4u) return 0.08;// sand
    if (id==1u) return 0.06;// grass
    if (id==2u) return 0.04;// dirt
    if (id==6u) return 0.07;// log
    if (id==7u) return 0.03;// leaves
    if (id==8u) return 0.05;// cactus
    return 0.05;
}

// Skylight: cosine-weighted hemisphere sample of envSky with occlusion
vec3 computeSkyIrradiance(vec3 pHit, vec3 n){
    const int SKY_SAMPLES = 12;
    vec3 sum = vec3(0.0);
    float W  = 0.0;

    for (int i=0; i<SKY_SAMPLES; ++i){
        float u = (float(i)+0.5)/float(SKY_SAMPLES);
        float phi = GOLDEN_ANGLE * float(i);
        float y = u;
        float r = sqrt(max(0.0, 1.0 - y*y));
        vec3  L = vec3(cos(phi)*r, y, sin(phi)*r);// world-up oriented
        float k = max(dot(n, L), 0.0);
        if (k <= 0.0) continue;
        bool oc = traverseHitAny(pHit + L*1e-3, L);
        if (!oc) sum += envSky(L) * k;
        W += k;
    }
    return (W > 0.0) ? (sum / W) : vec3(0.0);
}

float computeAmbientOcclusion(vec3 pHit, vec3 n){
    if (uAOEnabled == 0) return 1.0;
    int samples = clamp(uAOSampleCount, 0, MAX_AO_SAMPLES);
    if (samples <= 0) return 1.0;
    float radius = max(uAORadius, 0.0);
    if (radius <= 1e-4) return 1.0;

    vec3 T, B; makeONB(n, T, B);
    float occlusion = 0.0;
    float weightSum = 0.0;

    for (int i=0; i<samples; ++i){
        float u = (float(i) + 0.5) / float(samples);
        float v = fract(float(i) * 0.75487766);
        float cosTheta = sqrt(max(0.0, 1.0 - u));
        float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
        float phi = TAU * v;
        vec3 hemi = vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);
        vec3 sampleDir = normalize(hemi.x * T + hemi.y * n + hemi.z * B);
        float weight = max(dot(n, sampleDir), 0.0);
        if (weight <= 1e-4) continue;
        bool blocked = traverseHitAnyDistance(pHit + sampleDir * 1e-3, sampleDir, radius);
        if (blocked) occlusion += weight;
        weightSum += weight;
    }

    if (weightSum <= 1e-4) return 1.0;
    float occ = occlusion / weightSum;
    float intensity = max(uAOIntensity, 0.0);
    float scaled = clamp(occ * intensity, 0.0, 1.0);
    return saturate(1.0 - scaled);
}

vec3 computeDirectLighting(vec3 albedo, vec3 pHit, vec3 n){
    vec3 Ls = normalize(uSunDir);
    float ndl = max(dot(n, Ls), 0.0);
    float sunVis = (ndl > 0.0) ? sunVisibility(pHit, n) : 0.0;
    vec3 result = albedo * (ndl * sunVis);

    if (uTorchEnabled != 0){
        result += evaluateAreaLight(albedo, pHit, n, uTorchPos, vec3(1.0), uTorchIntensity, uTorchRadius, 0.0, max(uTorchSoftSamples, 1));
    }

    int count = clamp(uLightCount, 0, MAX_DYNAMIC_LIGHTS);
    int samples = max(uLightSoftSamples, 1);
    for (int i=0; i<count; ++i){
        vec4 lp = uLightPositions[i];
        vec4 lc = uLightColors[i];
        if (lc.a <= 0.0) continue;
        float radius = uLightRadii[i];
        float range = lp.w;
        result += evaluateAreaLight(albedo, pHit, n, lp.xyz, lc.rgb, lc.a, radius, range, samples);
    }
    return result;
}

vec3 sampleGIVolume(vec3 worldPos){
    if (uGIVolumeEnabled == 0) return vec3(0.0);
    vec3 size = vec3(uGIVolumeSize);
    if (size.x <= 0.0 || size.y <= 0.0 || size.z <= 0.0) return vec3(0.0);
    float cellSize = max(uGIVolumeCellSize, 1e-4);
    vec3 coord = (worldPos - uGIVolumeOrigin) / cellSize;
    vec3 uvw = (coord + vec3(0.5)) / size;
    if (any(lessThan(uvw, vec3(0.0))) || any(greaterThan(uvw, vec3(1.0)))) return vec3(0.0);
    return texture(uGIVolume, uvw).rgb;
}

vec3 computeVolumeGI(vec3 albedo, vec3 pHit, vec3 n){
    if (uGIVolumeEnabled == 0) return vec3(0.0);
    vec3 worldPos = pHit + vec3(uRegionOrigin);
    vec3 sum = vec3(0.0);
    float weightSum = 0.0;

    vec3 baseSample = sampleGIVolume(worldPos);
    if (any(greaterThan(baseSample, vec3(1e-5)))){
        sum += baseSample * 0.35;
        weightSum += 0.35;
    }

    vec3 T, B; makeONB(n, T, B);
    int cones = clamp(uGISampleCount, 1, 6);
    float stepSize = max(uGIVolumeCellSize, 1e-3);
    for (int i=0; i<cones; ++i){
        vec3 dir;
        if (i == 0) dir = n;
        else if (i == 1) dir = normalize(n + T);
        else if (i == 2) dir = normalize(n - T);
        else if (i == 3) dir = normalize(n + B);
        else if (i == 4) dir = normalize(n - B);
        else dir = normalize(n + T + B);
        float distance = stepSize * (1.0 + float(i) * 0.75);
        vec3 samplePos = worldPos + dir * distance;
        vec3 sampleValue = sampleGIVolume(samplePos);
        float weight = max(dot(n, dir), 0.0);
        if (weight <= 1e-4) continue;
        sum += sampleValue * weight;
        weightSum += weight;
    }

    if (weightSum <= 1e-4) return vec3(0.0);
    return albedo * (sum / weightSum) * uGIIntensity;
}

vec3 computeIndirectGIPathTrace(vec3 albedo, vec3 pHit, vec3 n){
    int samples = clamp(uGISampleCount, 0, MAX_GI_SAMPLES);
    if (samples <= 0) return vec3(0.0);

    vec3 T, B; makeONB(n, T, B);
    vec3 sum = vec3(0.0);
    float weightSum = 0.0;
    int traceSteps = max(uSecondaryTraceMaxSteps, 1);

    for (int i=0; i<samples; ++i){
        float u = (float(i) + 0.5) / float(samples);
        float v = fract(float(i) * 0.75487766);
        float cosTheta = sqrt(max(0.0, 1.0 - u));
        float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
        float phi = TAU * v;
        vec3 hemi = vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);
        vec3 sampleDir = normalize(hemi.x * T + hemi.y * n + hemi.z * B);

        vec3 start = pHit + n * 1e-3;
        vec3 hitPos, hitNormal;
        uint hitId;
        if (traceVoxel(start, sampleDir, uGIMaxDistance, traceSteps, hitPos, hitNormal, hitId)){
            vec3 bounceAlbedo = blockColor(hitId);
            vec3 bounce = computeDirectLighting(bounceAlbedo, hitPos, hitNormal)
                        + bounceAlbedo * computeSkyIrradiance(hitPos, hitNormal);
            float weight = max(dot(n, sampleDir), 0.0);
            sum += bounce * weight;
            weightSum += weight;
        } else {
            float weight = max(dot(n, sampleDir), 0.0);
            sum += envSky(sampleDir) * weight;
            weightSum += weight;
        }
    }

    if (weightSum > 0.0) sum /= weightSum;
    return albedo * sum * uGIIntensity;
}

vec3 computeIndirectGI(vec3 albedo, vec3 pHit, vec3 n){
    if (uGIEnabled == 0) return vec3(0.0);
    if (uGIVolumeEnabled != 0){
        vec3 volumeGi = computeVolumeGI(albedo, pHit, n);
        float peak = max(max(volumeGi.r, volumeGi.g), volumeGi.b);
        if (peak > 1e-4) return volumeGi;
    }
    return computeIndirectGIPathTrace(albedo, pHit, n);
}

vec3 computeReflections(uint blockId, vec3 albedo, vec3 pHit, vec3 n, vec3 viewDir){
    if (uReflectionEnabled == 0) return vec3(0.0);
    float reflectivity = blockReflectivity(blockId) * uReflectionIntensity;
    if (reflectivity <= 0.0) return vec3(0.0);

    vec3 reflectDir = normalize(reflect(-viewDir, n));
    vec3 start = pHit + reflectDir * 1e-3;
    vec3 hitPos, hitNormal;
    uint hitId;
    bool hit = traceVoxel(start, reflectDir, uReflectionMaxDistance, uSecondaryTraceMaxSteps, hitPos, hitNormal, hitId);
    vec3 reflectedColor = envSky(reflectDir);
    if (hit){
        vec3 hitAlbedo = blockColor(hitId);
        reflectedColor = computeDirectLighting(hitAlbedo, hitPos, hitNormal)
                       + hitAlbedo * computeSkyIrradiance(hitPos, hitNormal);
    }
    return reflectedColor * reflectivity;
}

vec3 shadeVoxel(uint blockId, vec3 pHit, vec3 n, vec3 viewDir){
    vec3 albedo = blockColor(blockId);
    vec3 direct = computeDirectLighting(albedo, pHit, n);
    vec3 skyl = albedo * computeSkyIrradiance(pHit, n);
    vec3 gi = computeIndirectGI(albedo, pHit, n);
    vec3 refl = computeReflections(blockId, albedo, pHit, n, viewDir);
    float ao = computeAmbientOcclusion(pHit, n);
    vec3 ambient = (skyl + gi + refl) * ao;
    return direct + ambient;
}

// --------------------------- main ---------------------------
void main(){
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= uResolution.x || gid.y >= uResolution.y) return;

    // Primary ray
    vec2 uv = (vec2(gid) + vec2(0.5)) / vec2(uResolution) * 2.0 - 1.0;
    vec4 pNear = uInvProj * vec4(uv, -1.0, 1.0);
    vec4 pFar  = uInvProj * vec4(uv, 1.0, 1.0);
    pNear /= pNear.w; pFar /= pFar.w;

    vec3 ro = uCamPos;
    vec3 rd = normalize((uInvView * vec4(normalize(pFar.xyz - pNear.xyz), 0.0)).xyz);
    vec3 roLocal = ro - vec3(uRegionOrigin);

    // Region AABB
    vec3 tMin = (vec3(0.0) - roLocal) / rd;
    vec3 tMax = (vec3(uWorldSize) - roLocal) / rd;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tEnter = max(max(t1.x, t1.y), t1.z);
    float tExit  = min(min(t2.x, t2.y), t2.z);
    if (tExit < max(tEnter, 0.0)){
        imageStore(uOutput, gid, vec4(envSky(rd), 1.0));
        return;
    }

    // DDA setup with multi-tier distance-based LOD
    float tEnterClamped = max(tEnter, 0.0);
    vec3  dirStep = sign(rd);
    ivec3 stepI   = ivec3(dirStep);
    ivec3 off     = ivec3(stepI.x > 0 ? 1 : 0,
    stepI.y > 0 ? 1 : 0,
    stepI.z > 0 ? 1 : 0);

    bool hit = false;
    uint blockId = 0u;
    vec3 color = vec3(0.0);

    float lodScaleNear = max(uLodScale, 1.0);
    float lodScaleFar = max(max(uLodScaleFar, lodScaleNear), 1.0);
    float lodSwitchNear = max(uLodSwitchDistance, 0.0);
    float lodSwitchFar = max(uLodSwitchDistanceFar, lodSwitchNear);
    float lodBand = max(uLodTransitionBand, 0.0);

    bool useNear = (lodScaleNear > 1.0) && (lodSwitchNear > 0.0);
    bool useFar = (lodScaleFar > lodScaleNear) && (lodSwitchFar > lodSwitchNear);

    float accumulatedT = 0.0;
    bool continueTracing = true;

    if (useFar && continueTracing){
        vec3 pStartFar = roLocal + rd * tEnterClamped;
        float startDistFar = length(pStartFar);
        if (startDistFar > lodSwitchFar + lodBand){
            ivec3 vFar = ivec3(floor(pStartFar / lodScaleFar));
            vec3 nextBoundaryFar = vec3(vFar + off) * lodScaleFar;
            vec3 tMaxFar  = (nextBoundaryFar - pStartFar) / rd;
            vec3 tDeltaFar = abs(lodScaleFar / rd);
            vec3 lastNFar = vec3(0.0);
            float farT = 0.0;

            for (int iter=0; iter<1024; ++iter){
                if (!inBoundsFar(vFar)){ continueTracing = false; break; }

                vec3 cellCenter = vec3(vFar) * lodScaleFar + vec3(0.5 * lodScaleFar);
                float distFar = length(cellCenter - roLocal);
                if (distFar <= lodSwitchFar - lodBand){
                    break;
                }

                uint farId = loadVoxelFar(vFar);
                if (farId != 0u){
                    vec3 n = any(notEqual(lastNFar, vec3(0.0))) ? normalize(lastNFar) : normalize(-rd);
                    vec3 pHit = cellCenter + n * (0.5 * lodScaleFar);
                    color = shadeVoxel(farId, pHit, n, rd);
                    blockId = farId;
                    hit = true;
                    continueTracing = false;
                    break;
                }

                if (tMaxFar.x < tMaxFar.y){
                    if (tMaxFar.x < tMaxFar.z){
                        farT = tMaxFar.x;
                        vFar.x += stepI.x;
                        tMaxFar.x += tDeltaFar.x;
                        lastNFar = vec3(-dirStep.x, 0.0, 0.0);
                    } else {
                        farT = tMaxFar.z;
                        vFar.z += stepI.z;
                        tMaxFar.z += tDeltaFar.z;
                        lastNFar = vec3(0.0, 0.0, -dirStep.z);
                    }
                } else {
                    if (tMaxFar.y < tMaxFar.z){
                        farT = tMaxFar.y;
                        vFar.y += stepI.y;
                        tMaxFar.y += tDeltaFar.y;
                        lastNFar = vec3(0.0, -dirStep.y, 0.0);
                    } else {
                        farT = tMaxFar.z;
                        vFar.z += stepI.z;
                        tMaxFar.z += tDeltaFar.z;
                        lastNFar = vec3(0.0, 0.0, -dirStep.z);
                    }
                }
            }

            if (continueTracing && !hit){
                accumulatedT += farT;
            }
        }
    }

    if (continueTracing && !hit && useNear){
        float stageStartT = tEnterClamped + accumulatedT;
        if (stageStartT > tExit){
            continueTracing = false;
        } else {
            vec3 pStartNear = roLocal + rd * stageStartT;
            float startDistNear = length(pStartNear);
            if (startDistNear > lodSwitchNear + lodBand){
                ivec3 vCoarse = ivec3(floor(pStartNear / lodScaleNear));
                vec3 nextBoundaryCoarse = vec3(vCoarse + off) * lodScaleNear;
                vec3 tMaxCoarse  = (nextBoundaryCoarse - pStartNear) / rd;
                vec3 tDeltaCoarse = abs(lodScaleNear / rd);
                vec3 lastNNear = vec3(0.0);
                float coarseT = 0.0;

                for (int iter=0; iter<2048; ++iter){
                    if (!inBoundsCoarse(vCoarse)){ continueTracing = false; break; }

                    vec3 cellCenter = vec3(vCoarse) * lodScaleNear + vec3(0.5 * lodScaleNear);
                    float distCoarse = length(cellCenter - roLocal);
                    if (distCoarse <= lodSwitchNear - lodBand){
                        break;
                    }

                    uint coarseId = loadVoxelCoarse(vCoarse);
                    if (coarseId != 0u){
                        vec3 n = any(notEqual(lastNNear, vec3(0.0))) ? normalize(lastNNear) : normalize(-rd);
                        vec3 pHit = cellCenter + n * (0.5 * lodScaleNear);
                        color = shadeVoxel(coarseId, pHit, n, rd);
                        blockId = coarseId;
                        hit = true;
                        continueTracing = false;
                        break;
                    }

                    if (tMaxCoarse.x < tMaxCoarse.y){
                        if (tMaxCoarse.x < tMaxCoarse.z){
                            coarseT = tMaxCoarse.x;
                            vCoarse.x += stepI.x;
                            tMaxCoarse.x += tDeltaCoarse.x;
                            lastNNear = vec3(-dirStep.x, 0.0, 0.0);
                        } else {
                            coarseT = tMaxCoarse.z;
                            vCoarse.z += stepI.z;
                            tMaxCoarse.z += tDeltaCoarse.z;
                            lastNNear = vec3(0.0, 0.0, -dirStep.z);
                        }
                    } else {
                        if (tMaxCoarse.y < tMaxCoarse.z){
                            coarseT = tMaxCoarse.y;
                            vCoarse.y += stepI.y;
                            tMaxCoarse.y += tDeltaCoarse.y;
                            lastNNear = vec3(0.0, -dirStep.y, 0.0);
                        } else {
                            coarseT = tMaxCoarse.z;
                            vCoarse.z += stepI.z;
                            tMaxCoarse.z += tDeltaCoarse.z;
                            lastNNear = vec3(0.0, 0.0, -dirStep.z);
                        }
                    }
                }

                if (continueTracing && !hit){
                    accumulatedT += coarseT;
                }
            }
        }
    }

    if (continueTracing && !hit){
        float fineStartT = tEnterClamped + accumulatedT;
        if (fineStartT <= tExit){
            float tFineParam = min(fineStartT + 1e-4, tExit);
            vec3 pFine = roLocal + rd * tFineParam;
            ivec3 v = ivec3(floor(pFine));
            vec3 nextBoundary = vec3(v + off);
            vec3 tMax3  = (nextBoundary - pFine) / rd;
            vec3 tDelta = abs(1.0 / rd);
            vec3 lastN = vec3(0.0);

            for (int iter=0; iter<4096; ++iter){
                if (!inBounds(v)) break;

                blockId = loadVoxel(v);
                if (blockId != 0u){
                    vec3 n = any(notEqual(lastN, vec3(0.0))) ? normalize(lastN) : normalize(-rd);
                    vec3 pHit = vec3(v) + vec3(0.5) + 0.5 * n;
                    color = shadeVoxel(blockId, pHit, n, rd);
                    hit = true;
                    break;
                }

                if (tMax3.x < tMax3.y){
                    if (tMax3.x < tMax3.z){
                        v.x += stepI.x;
                        tMax3.x += tDelta.x;
                        lastN = vec3(-dirStep.x, 0.0, 0.0);
                    } else {
                        v.z += stepI.z;
                        tMax3.z += tDelta.z;
                        lastN = vec3(0.0, 0.0, -dirStep.z);
                    }
                } else {
                    if (tMax3.y < tMax3.z){
                        v.y += stepI.y;
                        tMax3.y += tDelta.y;
                        lastN = vec3(0.0, -dirStep.y, 0.0);
                    } else {
                        v.z += stepI.z;
                        tMax3.z += tDelta.z;
                        lastN = vec3(0.0, 0.0, -dirStep.z);
                    }
                }
            }
        }
    }

    imageStore(uOutput, gid, vec4(hit ? color : envSky(rd), 1.0));
}
